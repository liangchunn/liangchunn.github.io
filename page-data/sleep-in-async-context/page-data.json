{"componentChunkName":"component---src-templates-blog-post-js","path":"/sleep-in-async-context/","result":{"data":{"site":{"siteMetadata":{"title":"TypeError"}},"markdownRemark":{"id":"9873c9c9-3a64-5e7c-ad06-68839b2a867d","excerpt":"I recently built a Rust library that allows you to query Impala databases for an API that needs to query data from Impala. The library interfaces with an Impala…","html":"<p>I recently built a Rust library that allows you to query Impala databases for an API that needs to query data from Impala.</p>\n<p>The library interfaces with an Impala database via the Thrift interface, namely via the interface defined by the <a href=\"https://github.com/apache/hive/blob/master/service-rpc/if/TCLIService.thrift\"><code class=\"language-text\">TCLIService.thrift</code></a> definition file. Using the Apache Thrift CLI tool, the bindings file for Rust can be generated to be used with the <a href=\"https://crates.io/crates/thrift\"><code class=\"language-text\">thrift</code></a> crate.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">thrift -out src --gen rs -r ./thrift/TCLIService.thrift</code></pre></div>\n<p>The synchronous API was first built to test things out (which involves a lot of transformations like transposing rows, getting metadata, and more shenanigans). Then the asynchronous API was built with the help of <code class=\"language-text\">bb8</code> and <code class=\"language-text\">thrift-pool</code> which allows the underlying TCP connections to be reused since they are expensive to reopen every time a query fires.</p>\n<p>Since this was the first time I was touching code related to such low-level interfaces, there were some bugs like a query only returning a maximum of <code class=\"language-text\">1024</code> rows due to a limit imposed on the server side, requiring the query to be sent again <em>on the same session</em> with all the same parameters.</p>\n<p>Nonetheless, we deployed the first iteration of the product which uses this Impala libary and I noticed something weird.</p>\n<h3>More CPUs, please</h3>\n<p>Since Impala iteself is kinda slow, I expected that the requests (that requires calling to Impala) to be slow. My response was to bump up the number of CPUs, since at the time of the pre-release, there was only 1 CPU instance allocated to the whole container running the server.</p>\n<p>The reasoning was: if there’s more CPUs, then the <code class=\"language-text\">actix-web</code> server can use more CPUs to run tasks, and there will be less contention between the system processes and the server.</p>\n<p>After deploying the new version onto Google Cloud, I tested the application by requesting some routes, and everything <em>seemed fine</em> to me.</p>\n<h3>Shipping it</h3>\n<p>On the day of release, multiple users reported that there was issues loading resources from the API. They were being timed out constantly.</p>\n<p>Looking at the logs, I found that some routes on the server which were not supposed to be slow, <strong>were slow</strong>.</p>\n<p>An example is the auth route. This route checks if your auth cookie is still valid, and it should be nearly instant (!), but it was taking <strong>more than 4 seconds</strong>, and sometimes even <strong>more than 10 seconds</strong> to be processed. When this happens, it triggers Google Cloud to timeout the request and return a HTTP 408.</p>\n<h3>The investigation</h3>\n<p>I tried to reproduce the issue on my local machine by limiting the server to only utilise 1 thread, firing the slow request, and then firing multiple requests that were not supposed to be slow in quick succession.</p>\n<p>As expected (not to my advantage), the supposedly fast requests were being slow, and they were <em>suspiciously slow</em> because the response times were <em>almost the same</em> as the slow request!</p>\n<h3>The problem</h3>\n<p>As the title suggests, the problem is caused by the <strong>usage of <code class=\"language-text\">std::thread::sleep</code> in an <code class=\"language-text\">async</code> context</strong>.</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">if</span> <span class=\"token operator\">!</span><span class=\"token macro property\">matches!</span><span class=\"token punctuation\">(</span>\n    response<span class=\"token punctuation\">.</span>operation_state<span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TOperationState</span><span class=\"token punctuation\">::</span><span class=\"token constant\">RUNNING_STATE</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">|</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TOperationState</span><span class=\"token punctuation\">::</span><span class=\"token constant\">PENDING_STATE</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">|</span> <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">TOperationState</span><span class=\"token punctuation\">::</span><span class=\"token constant\">INITIALIZED_STATE</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token namespace\">log<span class=\"token punctuation\">::</span></span><span class=\"token macro property\">info!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"execute operation done in {:?}\"</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">.</span><span class=\"token function\">elapsed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> sleep_duration <span class=\"token operator\">=</span> <span class=\"token function\">get_sleep_duration</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token namespace\">log<span class=\"token punctuation\">::</span></span><span class=\"token macro property\">trace!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" sleeping for {:.2?}\"</span><span class=\"token punctuation\">,</span> sleep_duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// Oops!</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>thread<span class=\"token punctuation\">::</span></span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>sleep_duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I promptly switched the implementation to use <code class=\"language-text\">tokio::time::sleep</code> instead (which fixed the issue), as the documentation of <code class=\"language-text\">std::thread::sleep</code> says:</p>\n<blockquote>\n<p>Puts the current thread to sleep for at least the specified amount of time.</p>\n<p>The thread may sleep longer than the duration specified due to scheduling specifics or\nplatform-dependent functionality. It will never sleep less.</p>\n<p><strong>This function is blocking, and should not be used in async functions.</strong></p>\n</blockquote>\n<p>During the porting of the synchronous API to the asyncronous API of the Impala library, I didn’t manage to catch this and mostly ported everything 1-to-1 (since the mechanism of firing queries is the same). I thought to myself: isn’t there a clippy lint for this that could have caught this issue?</p>\n<p>Turns out, <em>there isn’t</em>.</p>\n<p>There was an issue opened in <code class=\"language-text\">rust-clippy</code> titled <a href=\"https://github.com/rust-lang/rust-clippy/issues/4377\">“Lint idea: find known-blocking constructs in async contexts”</a>, but it wasn’t in favour to be implemented in clippy because it <a href=\"https://github.com/rust-lang/rust-clippy/pull/9857#issuecomment-1316377961\">requires global analysis</a>, which is something that clippy shouldn’t do due to perfomance reasons.</p>\n<h3>Async mindfield</h3>\n<p>All of this reminds me of how difficult it is to implement <code class=\"language-text\">async</code> Rust. I remembered one time where I freaked out when I saw the <code class=\"language-text\">Future</code> trait:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">trait</span> <span class=\"token class-name\">Future</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span> <span class=\"token class-name\">Output</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Required method</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">:</span> <span class=\"token class-name\">Pin</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">Self</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> cx<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token class-name\">Context</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'_</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Poll</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">Self</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Output</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">Pin</code>? <code class=\"language-text\">Poll</code>? What the hell is this? Let me see… oh, okay nevermind.</p>\n</blockquote>\n<p>Suffice to say I quietly stepped away from this, and I just <em>never</em> return <code class=\"language-text\">Future</code>-y things from functions or even try to touch <code class=\"language-text\">Future</code> related things by using <code class=\"language-text\">async fn</code> and <code class=\"language-text\">.await</code> everywhere that I could. Maybe one day I am able to muster the confidence to <em>truly</em> understand it.</p>\n<p>Don’t get me wrong, I am quite satisfied with how Rust handles async and being extremely explicit, but I do wish there was some tool that would have caught this issue for me, which would have in turn make working with <code class=\"language-text\">async</code> easier.</p>\n<h3>Take aways</h3>\n<p>Some key take-aways:</p>\n<ul>\n<li>Be aware of blocking constructs in async contexts</li>\n<li>Never blindly port 1-to-1 from a synchronous implementation</li>\n<li>Take good care when implementing async</li>\n</ul>","frontmatter":{"title":"Sleep in Async Contexts","date":"June 16, 2023","description":null}},"previous":{"fields":{"slug":"/express-typescript-handlers/"},"frontmatter":{"title":"Using Express with Strictly Typed Handlers and Responses"}},"next":null},"pageContext":{"id":"9873c9c9-3a64-5e7c-ad06-68839b2a867d","previousPostId":"543907d7-f67c-5638-8129-47f985c2f836","nextPostId":null}},"staticQueryHashes":["2841359383","916993862"]}